/* listgen.c
**
** Copyright (c) 1990, Chris Laforet Software/Chris Laforet
** All Rights Reserved
**
** Started: 14 July 1989
**
** Revision Information: $Logfile$
**                       $Date$
**                       $Revision$
**
*/


#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#ifdef PROTECTED
	#define INCL_DOSFILEMGR
	#include <os2.h>
#else
	#include <dos.h>
#endif
#include "listgen.h"



#define MARGIN					33
#define MAXLINE					78


int level = 0;
FILE *pathfd;
FILE *listfd;
struct farea **fareas = NULL;
int cur_fareas = 0;
int max_fareas = 0;
struct file **files = NULL;
int cur_files = 0;
int max_files = 0;
int build_cref = 1;



int comp_name(struct file **arg1,struct file **arg2)
	{
	return(stricmp((*arg1)->file_name,(*arg2)->file_name));
	}



void cross_reference(void)
	{
	int count;

	qsort(files,cur_files,sizeof(struct file *),comp_name);
	fprintf(listfd,"\r\n\r\n\r\nCross Reference of Available Files:\r\n");
	fprintf(listfd,"----------------------------------\r\n\r\n");
	for (count = 0; count < cur_files; count++)
		{
		fprintf(listfd,"%-12.12s %9lu %02u-%02u-%02u   %-40.40s\r\n",files[count]->file_name,files[count]->file_size,(files[count]->file_date >> 5) & 0xf,files[count]->file_date & 0x1f,
			(((files[count]->file_date >> 9) & 0x7f) + 80) % 100,fareas[files[count]->file_area]->farea_areaname[0] ? fareas[files[count]->file_area]->farea_areaname : "");
        }
	}



void list_files(void)
	{
	struct fe tfe;
	char buffer[120];
	char path[100];
	char descrip[81];
	char *cptr;
	char *cptr1;
	int count;
	int kount;
	int done = 0;
	FILE *fd;
	int line;
	int len;
#ifdef PROTECTED
	FILEFINDBUF find;
	HDIR hdir;
	int search;
#else
	struct find_t find;
#endif

	if (fd = fopen("listgen.top","rb"))
		{
		printf("Reading filelist header...\n");
		while (fgets(buffer,sizeof(buffer),fd))
			fprintf(listfd,"%s",buffer);
		fclose(fd);
		}

	_strdate(buffer);
	fprintf(listfd,"File Area Listing as of %s:\r\n",buffer);
	fprintf(listfd,"--------------------------------\r\n\r\n");
	fprintf(listfd,"* Generated by Listgen (v %u.%02u of %s) by Chris Laforet Software.\r\n\r\n\r\n",MAJOR_VERSION,MINOR_VERSION,__DATE__);
	for (count = 0; count < cur_fareas; count++)
		{
		if (fareas[count]->farea_areaname)
			{
			fprintf(listfd,">>--> Listing for \"%s\"....\r\n\r\n",fareas[count]->farea_areaname);
			printf("Listing: %s\n",fareas[count]->farea_areaname);
			}

		if (fareas[count]->farea_descname[0])			/* copy over the header */
			strcpy(path,fareas[count]->farea_descname);
		else 
			strcpy(path,fareas[count]->farea_pathname);
		if (path[0] && path[strlen(path) - 1] != P_CSEP)
			strcat(path,P_SSEP);
		strcat(path,"filehead.bbs");
		if (fd = fopen(path,"rb"))
			{
			while (fgets(buffer,sizeof(buffer),fd))
				fwrite(buffer,strlen(buffer),sizeof(char),listfd);
			fprintf(listfd,"\r\n");
			fclose(fd);
			}

		if (fareas[count]->farea_descname[0])
			strcpy(path,fareas[count]->farea_descname);
		else 
			strcpy(path,fareas[count]->farea_pathname);
		if (path[0] && path[strlen(path) - 1] != P_CSEP)
			strcat(path,P_SSEP);
		strcat(path,"filelist.bbs");
		if (fd = fopen(path,"rb"))
			{
			while (fread(&tfe,sizeof(struct fe),1,fd))
				{
				if ((unsigned int)level >= tfe.fe_priv)
					{
					strcpy(path,fareas[count]->farea_pathname);
					if (path[0] && path[strlen(path) - 1] != P_CSEP)
						strcat(path,P_SSEP);
					strcat(path,tfe.fe_name);

#ifdef PROTECTED
			   		search = 1;
			   		hdir = HDIR_SYSTEM;
			   		if (!DosFindFirst(path,&hdir,FILE_NORMAL | FILE_ARCHIVED | FILE_READONLY,&find,sizeof(FILEFINDBUF),&search,0L))
			   			fprintf(listfd,"%-12.12s %9lu %02u-%02u-%02u  ",tfe.fe_name,find.cbFile,find.fdateLastWrite.month,find.fdateLastWrite.day,(find.fdateLastWrite.year + 1980) % 100);
			   		else
			   			{
			   			fprintf(listfd,"%-12.12s -Missing-           ",tfe.fe_name);
			   			find.cbFile = 0xffffffffL;
			   			}

#else
			   		if (!_dos_findfirst(path,_A_ARCH | _A_RDONLY,&find))
			   			fprintf(listfd,"%-12.12s %9lu %02u-%02u-%02u  ",tfe.fe_name,find.size,(find.wr_date >> 5) & 0xf,find.wr_date & 0x1f,(((find.wr_date >> 9) & 0x7f) + 80) % 100);
			   		else
			   			{
			   			fprintf(listfd,"%-12.12s -Missing-           ",tfe.fe_name);
			   			find.size = 0xffffffffL;
			   			}
#endif

			   		line = 0;
					cptr = tfe.fe_descrip;
					while (*cptr)
						++cptr;
					while (cptr > cptr1 && *cptr <= ' ')
						--cptr;
					if (*cptr > ' ')
						++cptr;
					*cptr = '\0';
					cptr = tfe.fe_descrip;

					if (!*cptr)
						fprintf(listfd,"\r\n");
					else
						{
						while (*cptr)
							{
							cptr1 = descrip;
							len = 0;
							while (*cptr && len < MAXLINE - MARGIN)
								{
								*cptr1++ = *cptr++;
								++len;
								}

							if (len >= MAXLINE - MARGIN)
								{
								while (len && *cptr != ' ')
									{
									--cptr;
									--len;
									}

								if (len >= ((MAXLINE - MARGIN) / 2))
									cptr1 = descrip + len;
								else
									cptr += len;
								}

							*cptr1 = '\0';

							if (cptr1 != descrip)
								{
								if (line)
									{
									for (kount = 0; kount < MARGIN; kount++)
										fprintf(listfd," ");
									}
								++line;
								fprintf(listfd,"%s\r\n",descrip);
								}

							if (!line)
								fprintf(listfd,"\r\n");

							while (*cptr && *cptr == ' ')
								++cptr;
							}
						}

					if (build_cref)
						{
						if (cur_files >= max_files)
							{
							if (!(files = realloc(files,(max_files += 100) * sizeof(struct file *))))
								build_cref = 0;
							}
#ifdef PROTECTED
						if (build_cref && find.cbFile != 0xffffffffL)
#else
						if (build_cref && find.size != 0xffffffffL)
#endif
							{
							if (!(files[cur_files] = calloc(1,sizeof(struct file))))
								build_cref = 0;
							else
								{
								strcpy(files[cur_files]->file_name,tfe.fe_name);
								files[cur_files]->file_area = count;
#ifdef PROTECTED
								files[cur_files]->file_size = find.cbFile;
								files[cur_files]->file_date = ((unsigned int)find.fdateLastWrite.year << 9) | (find.fdateLastWrite.month << 5) | find.fdateLastWrite.day;
#else
								files[cur_files]->file_size = find.size;
								files[cur_files]->file_date = find.wr_date;
#endif
								++cur_files;
								}
							}
						}
					}
				}
			fprintf(listfd,"\r\n\r\n");
			fclose(fd);
			}
		else
			printf("Error: Unable to open \"%s\"!\n",path);
		}
	if (build_cref && cur_files)
		{
		printf("Now sorting and building cross-reference...\n");
		cross_reference();
		}
	}



void get_paths(void)
	{
	struct farea tfarea;

	while (fread(&tfarea,sizeof(struct farea),1,pathfd))
		{
		if (!(tfarea.farea_deleted) && level >= (int)tfarea.farea_priv && !tfarea.farea_flags)
			{
			if (cur_fareas >= max_fareas)
				{
				if (!(fareas = realloc(fareas,(max_fareas += 25) * sizeof(struct farea *))))
					{
					printf("Fatal Error: Out of memory!\n");
					exit(1);
					}
				}
			if (!(fareas[cur_fareas] = malloc(sizeof(struct farea))))
				{
				printf("Fatal Error: Out of memory!\n");
				exit(1);
				}
			memcpy(fareas[cur_fareas],&tfarea,sizeof(struct farea));
			++cur_fareas;
			}
		}
	}



int main(int argc,char *argv[])
	{
	char buffer[100];
	char *cptr;

#ifdef PROTECTED
	fprintf(stderr,"LISTGEN/2 (v %u.%02u of %s): A Simplex/2 File List Generator.\n",MAJOR_VERSION,MINOR_VERSION,__DATE__);
#else
	fprintf(stderr,"LISTGEN (v %u.%02u of %s): A Simplex File List Generator.\n",MAJOR_VERSION,MINOR_VERSION,__DATE__);
#endif
	fprintf(stderr,"Copyright (c) 1989,90, Chris Laforet Software.  All Rights Reserved.\n\n");
	if (argc < 3)
		{
		fprintf(stderr,"Usage is LISTGEN filename usage_level\n");
		fprintf(stderr,"\tListgen must be run in your Simplex directory or\n");
		fprintf(stderr,"\tthe environment variable SIMPLEX is used to locate\n");
		fprintf(stderr,"\tthe directory.  The file LISTGEN.TOP will be added\n");
		fprintf(stderr,"\tat the top of the file listing file.\n\n");
		exit(1);
		}
	if (isdigit(*argv[2]))
		level = atoi(argv[2]);
	else
		{
		printf("Fatal Error: Usage level must be numeric!\n");
		return 1;
		}
	if (level > 255)
		level = 255;

	if (!(pathfd = fopen("filearea.bbs","rb")))
		{
		if (cptr = getenv("SIMPLEX"))
			{
			strcpy(buffer,cptr);
			if (buffer[0] && buffer[strlen(buffer) - 1] != P_CSEP)
				strcat(buffer,P_SSEP);
			strcat(buffer,"filearea.bbs");
			pathfd = fopen(buffer,"rb");
			}
		}

	if (!pathfd)
		{
		printf("Fatal Error: Unable to find/open \"filearea.bbs\" file!\n");
		return 1;
		}

	if (!(listfd = fopen(argv[1],"wb")))
		{
		printf("Fatal Error: Unable to open list file!\n");
		return 1;
		}

	get_paths();
	fclose(pathfd);
	list_files();

	return(0);
	}



